# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'startgui.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.



# importing libraries
from PyQt5.QtWidgets import *
from PyQt5 import QtCore, QtGui
from PyQt5.QtGui import *
from PyQt5.QtCore import *
import glob
from fileviewer import Window
from threading import Thread
import sys
import math
import operator
import time
import Adafruit_ADS1x15
import traceback, sys
from datetime import datetime
import serial
import RPi.GPIO as GPIO
import os.path

class WorkerSignals(QObject):
    '''
    Defines the signals available from a running worker thread.

    Supported signals are:

    finished
        No data

    error
        tuple (exctype, value, traceback.format_exc() )

    result
        object data returned from processing, anything

    progress
        int indicating % progress

    '''
    finished = pyqtSignal()
    error = pyqtSignal(tuple)
    result = pyqtSignal(object)
    progress = pyqtSignal(int)


class Worker(QRunnable):
    '''
    Worker thread

    Inherits from QRunnable to handler worker thread setup, signals and wrap-up.

    :param callback: The function callback to run on this worker thread. Supplied args and
                     kwargs will be passed through to the runner.
    :type callback: function
    :param args: Arguments to pass to the callback function
    :param kwargs: Keywords to pass to the callback function

    '''

    def __init__(self, fn, *args, **kwargs):
        super(Worker, self).__init__()

        # Store constructor arguments (re-used for processing)
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()

        # Add the callback to our kwargs
        self.kwargs['progress_callback'] = self.signals.progress

    @pyqtSlot()
    def run(self):
        '''
        Initialise the runner function with passed args, kwargs.
        '''
        # Retrieve args/kwargs here; and fire processing using them
        try:
            result = self.fn(*self.args, **self.kwargs)
        except:
            traceback.print_exc()
            exctype, value = sys.exc_info()[:2]
            self.signals.error.emit((exctype, value, traceback.format_exc()))
        else:
            self.signals.result.emit(result)  # Return the result of the processing
        finally:
            self.signals.finished.emit()  # Done

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1024, 600)
        MainWindow.setStyleSheet("background-image : url(main.jpg)")
        self.centralwidget = QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.pushButton = QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QRect(925, 518, 100,40 ))
        self.pushButton.setObjectName("pushButton")
        self.pushButton.setStyleSheet("background-image : url(button.jpg)")
        self.lb_ph = QLabel(self.centralwidget)
        self.lb_ph.setGeometry(QRect(480, 215, 150, 90))
        self.lb_ph.setText("PHVAL")
        self.lb_ph.setObjectName("lb_qr")
        self.lb_ph.setStyleSheet("color: White")
        my_font = QFont("Comic Sans", 20)
        self.lb_ph.setFont(my_font)
        self.lb_temp = QLabel(self.centralwidget)
        self.lb_temp.setGeometry(QRect(480, 290, 150, 90))
        self.lb_temp.setText("TEMP")
        self.lb_temp.setObjectName("lbtemp")
        self.lb_temp.setFont(my_font)
        self.lb_temp.setStyleSheet("color: White")
        self.lb_turb = QLabel(self.centralwidget)
        self.lb_turb.setGeometry(QRect(480, 365, 150, 90))
        self.lb_turb.setText("TURB")
        self.lb_turb.setStyleSheet("color: White")
        self.lb_turb.setObjectName("lbturb")
        self.lb_turb.setFont(my_font)
        self.lb_amm = QLabel(self.centralwidget)
        self.lb_amm.setGeometry(QRect(480, 455, 150, 90))
        self.lb_amm.setText("NH3")
        self.lb_amm.setObjectName("lbturb")
        self.lb_amm.setFont(my_font)
        self.lb_amm.setStyleSheet("color: White")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QMenuBar(MainWindow)
        self.menubar.setGeometry(QRect(0, 0, 499, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.statusph = False
        self.statusturb = False
        self.statusamm = False
        self.statustemp = False
        self.tempval = 0
#       self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        txtfiles = []
        counter = 0       # creating scroll label
         #declare events
        self.pushButton.clicked.connect(self.on_button_clicked)
        self.threadpool = QThreadPool()
        print("Multithreading with maximum %d threads" % self.threadpool.maxThreadCount())
        worker = Worker(self.execute_this_fn) # Any other args, kwargs are passed to the run function
        worker.signals.result.connect(self.print_output)
        worker.signals.finished.connect(self.thread_complete)
        worker.signals.progress.connect(self.progress_fn)
        self.threadpool.start(worker)
        print("Multithreading with maximum %d threads" % self.threadpool.maxThreadCount())
        worker2 = Worker(self.sensorread) # Any other args, kwargs are passed to the run function
        worker2.signals.result.connect(self.print_output)
        worker2.signals.finished.connect(self.thread_complete)
        worker2.signals.progress.connect(self.progress_fn)
        # Execute
        self.threadpool.start(worker2)


    def on_button_clicked(self):
        self.Form = QWidget()
        self.ui = Window()
        #self.ui.setupUi(self.Form)
        #self.Form.show()
    def retranslateUi(self, MainWindow):
        _translate = QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "START"))
    def progress_fn(self, n):
        print("%d%% done" % n)

    def execute_this_fn(self, progress_callback):
        ser = serial.Serial(
                # Serial Port to read the data from
                port='/dev/ttyUSB0',
         
                #Rate at which the information is shared to the communication channel
                baudrate = 9600,
           
                #Applying Parity Checking (none in this case)
                parity=serial.PARITY_NONE,
         
               # Pattern of Bits to be read
                stopbits=serial.STOPBITS_ONE,
             
                # Total number of bits to be read
                bytesize=serial.EIGHTBITS,
         
                # Number of serial commands to accept before timing out
                timeout=1
        )
        counter=0
        # Mentions the Current Counter number for each line written
        # Pauses for one second each iteration to avoid overworking the port
        while 1:
            cc=ser.readline().decode().strip()
            result = cc.replace('.','')
            try:
                dres = float(result)
                print(type(result))
                print(type(dres))
                #self.lb_temp.setText(cc)
                self.tempval = dres/100.0
                print("Temperature:",tempval)
                if tempval <26.67 or tempval>31.67:
                    self.statustemp = True
                #apply function
                time.sleep(0.1)
            except:
                print("error")
        return "Done."

    def sensorread(self,progress_callback):
        t = 22 # assume current temperature. Recommended to measure with DHT22
        h = 65 # assume current humidity. Recommended to measure with DHT22

        """
        First version of an RaspBerryPi Library for the MQ135 gas sensor
        TODO: Review the correction factor calculation. This currently relies on
        the datasheet but the information there seems to be wrong.
        """

        # The load resistance on the board
        RLOAD = 10.0
        # Calibration resistance at atmospheric NH3 level
        RZERO = 76.63
        # Parameters for calculating ppm of NH3 from sensor resistance
        PARA = 116.6020682
        PARB = 2.769034857

        # Parameters to model temperature and humidity dependence
        CORA = 0.00035
        CORB = 0.02718
        CORC = 1.39538
        CORD = 0.0018
        CORE = -0.003333333
        CORF = -0.001923077
        CORG = 1.130128205

        # Atmospheric NH3 level for calibration purposes
        ATMONH3 = 397.13
        adc = Adafruit_ADS1x15.ADS1115()
        GAIN = 1
        """
        @brief  Get the correction factor to correct for temperature and humidity

        @param[in] t  The ambient air temperature
        @param[in] h  The relative humidity

        @return The calculated correction factor
        """
       

        def getCorrectionFactor(t,h,CORA,CORB,CORC,CORD,CORE,CORF,CORG):
            # Linearization of the temperature dependency curve under and above 20 degree C
            # below 20degC: fact = a * t * t - b * t - (h - 33) * d
            # above 20degC: fact = a * t + b * h + c
            # this assumes a linear dependency on humidity
            if t < 20:
                return CORA * t * t - CORB * t + CORC - (h-33.)*CORD
            else:
                return CORE * t + CORF * h + CORG

        """
        @brief  Get the resistance of the sensor, ie. the measurement value

        @return The sensor resistance in kOhm
        """

        def getResistance(value_pin,RLOAD):
            return ((1023./value_pin) - 1.)*RLOAD

        """
        @brief  Get the resistance of the sensor, ie. the measurement value corrected
                for temp/hum

        @param[in] t  The ambient air temperature
        @param[in] h  The relative humidity

        @return The corrected sensor resistance kOhm
        """

        def getCorrectedResistance(t,h,CORA,CORB,CORC,CORD,CORE,CORF,CORG,value_pin,RLOAD):
            return getResistance(value_pin,RLOAD) / getCorrectionFactor(t,h,CORA,CORB,CORC,CORD,CORE,CORF,CORG)

        """
        @brief  Get the ppm of NH3 sensed (assuming only NH3 in the air)

        @return The ppm of NH3 in the air
        """

        def getPPM(PARA,RZERO,PARB,value_pin,RLOAD):
            return PARA * math.pow((getResistance(value_pin,RLOAD)/RZERO), -PARB)

        """
        @brief  Get the ppm of NH3 sensed (assuming only NH3 in the air), corrected
                for temp/hum

        @param[in] t  The ambient air temperature
        @param[in] h  The relative humidity

        @return The ppm of NH3 in the air
        """

        def getCorrectedPPM(t,h,CORA,CORB,CORC,CORD,CORE,CORF,CORG,value_pin,RLOAD,PARA,RZERO,PARB):
            return PARA * math.pow((getCorrectedResistance(t,h,CORA,CORB,CORC,CORD,CORE,CORF,CORG,value_pin,RLOAD)/RZERO), -PARB)

        """
        @brief  Get the resistance RZero of the sensor for calibration purposes

        @return The sensor resistance RZero in kOhm
        """

        def getRZero(value_pin,RLOAD,ATMONH3,PARA,PARB):
            return getResistance(value_pin,RLOAD) * math.pow((ATMONH3/PARA), (1./PARB))

        """
        @brief  Get the corrected resistance RZero of the sensor for calibration
                purposes

        @param[in] t  The ambient air temperature
        @param[in] h  The relative humidity

        @return The corrected sensor resistance RZero in kOhm
        """

        def getCorrectedRZero(t,h,CORA,CORB,CORC,CORD,CORE,CORF,CORG,value_pin,RLOAD,ATMONH3,PARA,PARB):
            return getCorrectedResistance(t,h,CORA,CORB,CORC,CORD,CORE,CORF,CORG,value_pin,RLOAD) * math.pow((ATMONH3/PARA), (1./PARB))

        """
        Re-maps a number from one range to another. That is, a value of fromLow would get mapped to toLow,
        a value of fromHigh to toHigh, values in-between to values in-between, etc.

        # Arduino: (0 a 1023)
        # Raspberry Pi: (0 a 26690)

        More Info: https://www.arduino.cc/reference/en/language/functions/math/map/
        """

        def dmap(x,in_min,in_max,out_min,out_max):
            return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min
        adc = Adafruit_ADS1x15.ADS1115()
        GAIN = 1
        samples = 10
        avg = 0
        while True:
            # Read all the ADC channel values in a list.
            values = [0]*4
           
            for i in range(4):
                # Read the specified ADC channel using the 32767 set gain value.
                values[i] = adc.read_adc(i, gain=GAIN)
                # Note you can also pass in an optional data_rate parameter that controls
                # the ADC conversion time (in samples/second). Each chip has a different
                # set of allowed data rate values, see datasheet Table 9 config register
                # DR bit values.
                #values[i] = adc.read_adc(i, gain=GAIN, data_rate=128)
                # Each value will be a 12 or 16 bit signed integer value depending on the
                # ADC (ADS1015 = 12-bit, ADS1115 = 16-bit).
            # Print the ADC values.
            buf = list()
            for i in range(20): # Take 10 samples
                buf.append(adc.read_adc(2, gain=GAIN)*(4.1/32767))
            buf.sort() # Sort samples and discard highest and lowest
            buf = buf[2:-2]
            avg = (sum(map(float,buf))/16) # Get average value from remaining 6
            buf1 = list()
            for ii in range(20): # Take 10 samples
                buf1.append(adc.read_adc(0, gain=GAIN)*(4.1/32767))
            buf1.sort() # Sort samples and discard highest and lowest
            buf1 = buf1[2:-2]
            avg1 = (sum(map(float,buf1))/16) # Get average value from remaining 6
            #print(round(avg,2),'V')
            time.sleep(2)
            turbidityval = avg1
            res = -5.7959*avg + 21.649536 #computed slope
           
            if res >6.5 or res < 7.8:
                self.statusph = False
            else:
                self.statusph = True
                GPIO.setmode(GPIO.BCM)
                GPIO.setup(22,GPIO.OUT)
                GPIO.output(22,GPIO.HIGH)
                time.sleep(1)
                GPIO.output(22,GPIO.LOW)
               
               
            qualityturbidity = ""
            if turbidityval >= 1.50:
                qualityturbidity = "CLEAR"
                self.statusturb = False
            if turbidityval <= 1.64 or turbidityval >= 1.49:
                qualityturbidity = "CLOUDY"
                self.statusturb = False
            if turbidityval <= 1.48:
                qualityturbidity = "DIRTY"
                self.statusturb = True
                GPIO.setmode(GPIO.BCM)
                GPIO.setup(17,GPIO.OUT)
                GPIO.output(17,GPIO.HIGH)
                time.sleep(1)
                GPIO.output(17,GPIO.LOW)
               

            values = adc.read_adc(3, gain=GAIN)
            value_ads = values # value obtained by ADS1115
            value_pin = dmap((value_ads - 565), 0, 32767, 0, 1023) # 565 / 535 fix value
            rzero = getRZero(value_pin,RLOAD,ATMONH3,PARA,PARB)
            correctedRZero = getCorrectedRZero(t,h,CORA,CORB,CORC,CORD,CORE,CORF,CORG,value_pin,RLOAD,ATMONH3,PARA,PARB)
            resistance = getResistance(value_pin,RLOAD)
            ppm = getPPM(PARA,RZERO,PARB,value_pin,RLOAD)
            correctedPPM = getCorrectedPPM(t,h,CORA,CORB,CORC,CORD,CORE,CORF,CORG,value_pin,RLOAD,PARA,RZERO,PARB)
            if correctedPPM > 200:
                self.statusamm = True
                GPIO.setmode(GPIO.BCM)
                GPIO.setup(27,GPIO.OUT)
                GPIO.output(27,GPIO.HIGH)
                time.sleep(1)
                GPIO.output(27,GPIO.LOW)
               

       
            #print("\n MQ135 Gas Sensor:\n")
            #print("\t MQ135 RZero: %s" % round(rzero))
            #print("\t Corrected RZero: %s" % round(correctedRZero))
            #print("\t Resistance: %s" % round(resistance))
            #print("\t PPM: %s" % round(ppm))
            #print("\t Corrected PPM: %s ppm" % round(correctedPPM))

            #print("THIS IS VOLTAGE ",round(avg,2),'V'," THIS IS PH_formula0  ",round(ph_act,2))
            print("THIS IS VOLTAGE ",round(avg1,5),'V'," THIS IS WATER QUALITY  ",qualityturbidity)
            print("THIS IS VOLTAGE ",round(avg,5),'V'," THIS IS PH_formula2 ",round(res,5))
            print("NH3 PPM: %s ppm" % round(correctedPPM))
            self.lb_ph.setText(str(round(res,2)))
            self.lb_amm.setText(str(round(correctedPPM,2)) + " ppm")
            self.lb_turb.setText(qualityturbidity)
            self.lb_temp.setText(str(self.tempval))
            #check all sensor status
            if self.statusph == True or self.statusturb == True or self.statusamm == True or self.statustemp == True:
                print("DETECTED ")
                GPIO.setmode(GPIO.BCM)
                GPIO.setwarnings(False)
                GPIO.setup(4,GPIO.OUT)
                GPIO.output(4,GPIO.HIGH)
                time.sleep(1)
                GPIO.output(4,GPIO.LOW)
                now = datetime.now()
                print(now)
                dnow = now.strftime("%x")
                self.directory = "/home/pi/Desktop/Adafruit_Python_ADS1x15/examples/datalogs/"
                fname =  self.directory + str(dnow.replace('/','')) + ".txt"
                print(fname)
                txtmessage = str(now.strftime("%m/%d/%Y, %H:%M:%S")) + "\n" + "PH VALUE:" + str(round(res,2)) + "\n" + "TEMP VALUE:" + str(self.tempval) + "\n" +  "TURBIDITY:" + qualityturbidity + "\n" + "NH3 VALUE:" + str(round(correctedPPM,2)) + "\n"
                if os.path.isfile(fname):
                    try:
                        with open(fname, 'a') as f:
                            f.write(txtmessage)
                            print("successful")
                    except FileNotFoundError:
                            print("The 'docs' directory does not exist")  
                else:
                    try:
                        with open(fname, 'w') as f:
                            f.write(txtmessage)
                            print("successful")
                    except FileNotFoundError:
                            print("The 'docs' directory does not exist")                    
                print(now.date())
               
                   
            #print('| {0:>6} | {1:>6} | {2:>6} | {3:>6} |'.format(*values))
            # Pause for half a second.
            time.sleep(0.2)
       
    def print_output(self, s):
        print(s)

    def thread_complete(self):
        print("THREAD COMPLETE!")


if __name__ == "__main__":
    import sys
    app = QApplication(sys.argv)
    MainWindow = QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
